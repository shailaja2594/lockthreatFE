import { InjectionToken, ModuleWithProviders, ErrorHandler } from '@angular/core';
import { Router } from '@angular/router';
import { Selector, Store } from '@ngrx/store';
import { RouterReducerState } from './reducer';
import { RouterStateSerializer, BaseRouterStoreState } from './serializers/base';
import { SerializedRouterStateSnapshot } from './serializers/default_serializer';
import * as ɵngcc0 from '@angular/core';
export declare type StateKeyOrSelector<T extends BaseRouterStoreState = SerializedRouterStateSnapshot> = string | Selector<any, RouterReducerState<T>>;
/**
 * Full = Serializes the router event with DefaultRouterStateSerializer
 * Minimal = Serializes the router event with MinimalRouterStateSerializer
 */
export declare const enum RouterState {
    Full = 0,
    Minimal = 1
}
export interface StoreRouterConfig<T extends BaseRouterStoreState = SerializedRouterStateSnapshot> {
    stateKey?: StateKeyOrSelector<T>;
    serializer?: new (...args: any[]) => RouterStateSerializer;
    /**
     * By default, ROUTER_NAVIGATION is dispatched before guards and resolvers run.
     * Therefore, the action could run too soon, for example
     * there may be a navigation cancel due to a guard saying the navigation is not allowed.
     * To run ROUTER_NAVIGATION after guards and resolvers,
     * set this property to NavigationActionTiming.PostActivation.
     */
    navigationActionTiming?: NavigationActionTiming;
    /**
     * Decides which router serializer should be used, if there is none provided, and the metadata on the dispatched @ngrx/router-store action payload.
     * Set to `Full` to use the `DefaultRouterStateSerializer` and to set the angular router events as payload.
     * Set to `Minimal` to use the `MinimalRouterStateSerializer` and to set a minimal router event with the navigation id and url as payload.
     */
    routerState?: RouterState;
}
export declare enum NavigationActionTiming {
    PreActivation = 1,
    PostActivation = 2
}
export declare const _ROUTER_CONFIG: InjectionToken<{}>;
export declare const ROUTER_CONFIG: InjectionToken<{}>;
export declare const DEFAULT_ROUTER_FEATURENAME = "router";
export declare function _createRouterConfig(config: StoreRouterConfig): StoreRouterConfig;
/**
 * Connects RouterModule with StoreModule.
 *
 * During the navigation, before any guards or resolvers run, the router will dispatch
 * a ROUTER_NAVIGATION action, which has the following signature:
 *
 * ```
 * export type RouterNavigationPayload = {
 *   routerState: SerializedRouterStateSnapshot,
 *   event: RoutesRecognized
 * }
 * ```
 *
 * Either a reducer or an effect can be invoked in response to this action.
 * If the invoked reducer throws, the navigation will be canceled.
 *
 * If navigation gets canceled because of a guard, a ROUTER_CANCEL action will be
 * dispatched. If navigation results in an error, a ROUTER_ERROR action will be dispatched.
 *
 * Both ROUTER_CANCEL and ROUTER_ERROR contain the store state before the navigation
 * which can be used to restore the consistency of the store.
 *
 * Usage:
 *
 * ```typescript
 * @NgModule({
 *   declarations: [AppCmp, SimpleCmp],
 *   imports: [
 *     BrowserModule,
 *     StoreModule.forRoot(mapOfReducers),
 *     RouterModule.forRoot([
 *       { path: '', component: SimpleCmp },
 *       { path: 'next', component: SimpleCmp }
 *     ]),
 *     StoreRouterConnectingModule.forRoot()
 *   ],
 *   bootstrap: [AppCmp]
 * })
 * export class AppModule {
 * }
 * ```
 */
export declare class StoreRouterConnectingModule {
    private store;
    private router;
    private serializer;
    private errorHandler;
    private config;
    static forRoot<T extends BaseRouterStoreState = SerializedRouterStateSnapshot>(config?: StoreRouterConfig<T>): ModuleWithProviders<StoreRouterConnectingModule>;
    private lastEvent;
    private routerState;
    private storeState;
    private trigger;
    private stateKey;
    constructor(store: Store<any>, router: Router, serializer: RouterStateSerializer<SerializedRouterStateSnapshot>, errorHandler: ErrorHandler, config: StoreRouterConfig);
    private setUpStoreStateListener;
    private navigateIfNeeded;
    private setUpRouterEventsListener;
    private dispatchRouterRequest;
    private dispatchRouterNavigation;
    private dispatchRouterCancel;
    private dispatchRouterError;
    private dispatchRouterNavigated;
    private dispatchRouterAction;
    private reset;
    static ɵmod: ɵngcc0.ɵɵNgModuleDefWithMeta<StoreRouterConnectingModule, never, never, never>;
    static ɵinj: ɵngcc0.ɵɵInjectorDef<StoreRouterConnectingModule>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVyX3N0b3JlX21vZHVsZS5kLnRzIiwic291cmNlcyI6WyJyb3V0ZXJfc3RvcmVfbW9kdWxlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGlvblRva2VuLCBNb2R1bGVXaXRoUHJvdmlkZXJzLCBFcnJvckhhbmRsZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlciB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBTZWxlY3RvciwgU3RvcmUgfSBmcm9tICdAbmdyeC9zdG9yZSc7XG5pbXBvcnQgeyBSb3V0ZXJSZWR1Y2VyU3RhdGUgfSBmcm9tICcuL3JlZHVjZXInO1xuaW1wb3J0IHsgUm91dGVyU3RhdGVTZXJpYWxpemVyLCBCYXNlUm91dGVyU3RvcmVTdGF0ZSB9IGZyb20gJy4vc2VyaWFsaXplcnMvYmFzZSc7XG5pbXBvcnQgeyBTZXJpYWxpemVkUm91dGVyU3RhdGVTbmFwc2hvdCB9IGZyb20gJy4vc2VyaWFsaXplcnMvZGVmYXVsdF9zZXJpYWxpemVyJztcbmV4cG9ydCBkZWNsYXJlIHR5cGUgU3RhdGVLZXlPclNlbGVjdG9yPFQgZXh0ZW5kcyBCYXNlUm91dGVyU3RvcmVTdGF0ZSA9IFNlcmlhbGl6ZWRSb3V0ZXJTdGF0ZVNuYXBzaG90PiA9IHN0cmluZyB8IFNlbGVjdG9yPGFueSwgUm91dGVyUmVkdWNlclN0YXRlPFQ+Pjtcbi8qKlxuICogRnVsbCA9IFNlcmlhbGl6ZXMgdGhlIHJvdXRlciBldmVudCB3aXRoIERlZmF1bHRSb3V0ZXJTdGF0ZVNlcmlhbGl6ZXJcbiAqIE1pbmltYWwgPSBTZXJpYWxpemVzIHRoZSByb3V0ZXIgZXZlbnQgd2l0aCBNaW5pbWFsUm91dGVyU3RhdGVTZXJpYWxpemVyXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IGVudW0gUm91dGVyU3RhdGUge1xuICAgIEZ1bGwgPSAwLFxuICAgIE1pbmltYWwgPSAxXG59XG5leHBvcnQgaW50ZXJmYWNlIFN0b3JlUm91dGVyQ29uZmlnPFQgZXh0ZW5kcyBCYXNlUm91dGVyU3RvcmVTdGF0ZSA9IFNlcmlhbGl6ZWRSb3V0ZXJTdGF0ZVNuYXBzaG90PiB7XG4gICAgc3RhdGVLZXk/OiBTdGF0ZUtleU9yU2VsZWN0b3I8VD47XG4gICAgc2VyaWFsaXplcj86IG5ldyAoLi4uYXJnczogYW55W10pID0+IFJvdXRlclN0YXRlU2VyaWFsaXplcjtcbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCBST1VURVJfTkFWSUdBVElPTiBpcyBkaXNwYXRjaGVkIGJlZm9yZSBndWFyZHMgYW5kIHJlc29sdmVycyBydW4uXG4gICAgICogVGhlcmVmb3JlLCB0aGUgYWN0aW9uIGNvdWxkIHJ1biB0b28gc29vbiwgZm9yIGV4YW1wbGVcbiAgICAgKiB0aGVyZSBtYXkgYmUgYSBuYXZpZ2F0aW9uIGNhbmNlbCBkdWUgdG8gYSBndWFyZCBzYXlpbmcgdGhlIG5hdmlnYXRpb24gaXMgbm90IGFsbG93ZWQuXG4gICAgICogVG8gcnVuIFJPVVRFUl9OQVZJR0FUSU9OIGFmdGVyIGd1YXJkcyBhbmQgcmVzb2x2ZXJzLFxuICAgICAqIHNldCB0aGlzIHByb3BlcnR5IHRvIE5hdmlnYXRpb25BY3Rpb25UaW1pbmcuUG9zdEFjdGl2YXRpb24uXG4gICAgICovXG4gICAgbmF2aWdhdGlvbkFjdGlvblRpbWluZz86IE5hdmlnYXRpb25BY3Rpb25UaW1pbmc7XG4gICAgLyoqXG4gICAgICogRGVjaWRlcyB3aGljaCByb3V0ZXIgc2VyaWFsaXplciBzaG91bGQgYmUgdXNlZCwgaWYgdGhlcmUgaXMgbm9uZSBwcm92aWRlZCwgYW5kIHRoZSBtZXRhZGF0YSBvbiB0aGUgZGlzcGF0Y2hlZCBAbmdyeC9yb3V0ZXItc3RvcmUgYWN0aW9uIHBheWxvYWQuXG4gICAgICogU2V0IHRvIGBGdWxsYCB0byB1c2UgdGhlIGBEZWZhdWx0Um91dGVyU3RhdGVTZXJpYWxpemVyYCBhbmQgdG8gc2V0IHRoZSBhbmd1bGFyIHJvdXRlciBldmVudHMgYXMgcGF5bG9hZC5cbiAgICAgKiBTZXQgdG8gYE1pbmltYWxgIHRvIHVzZSB0aGUgYE1pbmltYWxSb3V0ZXJTdGF0ZVNlcmlhbGl6ZXJgIGFuZCB0byBzZXQgYSBtaW5pbWFsIHJvdXRlciBldmVudCB3aXRoIHRoZSBuYXZpZ2F0aW9uIGlkIGFuZCB1cmwgYXMgcGF5bG9hZC5cbiAgICAgKi9cbiAgICByb3V0ZXJTdGF0ZT86IFJvdXRlclN0YXRlO1xufVxuZXhwb3J0IGRlY2xhcmUgZW51bSBOYXZpZ2F0aW9uQWN0aW9uVGltaW5nIHtcbiAgICBQcmVBY3RpdmF0aW9uID0gMSxcbiAgICBQb3N0QWN0aXZhdGlvbiA9IDJcbn1cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IF9ST1VURVJfQ09ORklHOiBJbmplY3Rpb25Ub2tlbjx7fT47XG5leHBvcnQgZGVjbGFyZSBjb25zdCBST1VURVJfQ09ORklHOiBJbmplY3Rpb25Ub2tlbjx7fT47XG5leHBvcnQgZGVjbGFyZSBjb25zdCBERUZBVUxUX1JPVVRFUl9GRUFUVVJFTkFNRSA9IFwicm91dGVyXCI7XG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBfY3JlYXRlUm91dGVyQ29uZmlnKGNvbmZpZzogU3RvcmVSb3V0ZXJDb25maWcpOiBTdG9yZVJvdXRlckNvbmZpZztcbi8qKlxuICogQ29ubmVjdHMgUm91dGVyTW9kdWxlIHdpdGggU3RvcmVNb2R1bGUuXG4gKlxuICogRHVyaW5nIHRoZSBuYXZpZ2F0aW9uLCBiZWZvcmUgYW55IGd1YXJkcyBvciByZXNvbHZlcnMgcnVuLCB0aGUgcm91dGVyIHdpbGwgZGlzcGF0Y2hcbiAqIGEgUk9VVEVSX05BVklHQVRJT04gYWN0aW9uLCB3aGljaCBoYXMgdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gKlxuICogYGBgXG4gKiBleHBvcnQgdHlwZSBSb3V0ZXJOYXZpZ2F0aW9uUGF5bG9hZCA9IHtcbiAqICAgcm91dGVyU3RhdGU6IFNlcmlhbGl6ZWRSb3V0ZXJTdGF0ZVNuYXBzaG90LFxuICogICBldmVudDogUm91dGVzUmVjb2duaXplZFxuICogfVxuICogYGBgXG4gKlxuICogRWl0aGVyIGEgcmVkdWNlciBvciBhbiBlZmZlY3QgY2FuIGJlIGludm9rZWQgaW4gcmVzcG9uc2UgdG8gdGhpcyBhY3Rpb24uXG4gKiBJZiB0aGUgaW52b2tlZCByZWR1Y2VyIHRocm93cywgdGhlIG5hdmlnYXRpb24gd2lsbCBiZSBjYW5jZWxlZC5cbiAqXG4gKiBJZiBuYXZpZ2F0aW9uIGdldHMgY2FuY2VsZWQgYmVjYXVzZSBvZiBhIGd1YXJkLCBhIFJPVVRFUl9DQU5DRUwgYWN0aW9uIHdpbGwgYmVcbiAqIGRpc3BhdGNoZWQuIElmIG5hdmlnYXRpb24gcmVzdWx0cyBpbiBhbiBlcnJvciwgYSBST1VURVJfRVJST1IgYWN0aW9uIHdpbGwgYmUgZGlzcGF0Y2hlZC5cbiAqXG4gKiBCb3RoIFJPVVRFUl9DQU5DRUwgYW5kIFJPVVRFUl9FUlJPUiBjb250YWluIHRoZSBzdG9yZSBzdGF0ZSBiZWZvcmUgdGhlIG5hdmlnYXRpb25cbiAqIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlc3RvcmUgdGhlIGNvbnNpc3RlbmN5IG9mIHRoZSBzdG9yZS5cbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBATmdNb2R1bGUoe1xuICogICBkZWNsYXJhdGlvbnM6IFtBcHBDbXAsIFNpbXBsZUNtcF0sXG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICBCcm93c2VyTW9kdWxlLFxuICogICAgIFN0b3JlTW9kdWxlLmZvclJvb3QobWFwT2ZSZWR1Y2VycyksXG4gKiAgICAgUm91dGVyTW9kdWxlLmZvclJvb3QoW1xuICogICAgICAgeyBwYXRoOiAnJywgY29tcG9uZW50OiBTaW1wbGVDbXAgfSxcbiAqICAgICAgIHsgcGF0aDogJ25leHQnLCBjb21wb25lbnQ6IFNpbXBsZUNtcCB9XG4gKiAgICAgXSksXG4gKiAgICAgU3RvcmVSb3V0ZXJDb25uZWN0aW5nTW9kdWxlLmZvclJvb3QoKVxuICogICBdLFxuICogICBib290c3RyYXA6IFtBcHBDbXBdXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgU3RvcmVSb3V0ZXJDb25uZWN0aW5nTW9kdWxlIHtcbiAgICBwcml2YXRlIHN0b3JlO1xuICAgIHByaXZhdGUgcm91dGVyO1xuICAgIHByaXZhdGUgc2VyaWFsaXplcjtcbiAgICBwcml2YXRlIGVycm9ySGFuZGxlcjtcbiAgICBwcml2YXRlIGNvbmZpZztcbiAgICBzdGF0aWMgZm9yUm9vdDxUIGV4dGVuZHMgQmFzZVJvdXRlclN0b3JlU3RhdGUgPSBTZXJpYWxpemVkUm91dGVyU3RhdGVTbmFwc2hvdD4oY29uZmlnPzogU3RvcmVSb3V0ZXJDb25maWc8VD4pOiBNb2R1bGVXaXRoUHJvdmlkZXJzPFN0b3JlUm91dGVyQ29ubmVjdGluZ01vZHVsZT47XG4gICAgcHJpdmF0ZSBsYXN0RXZlbnQ7XG4gICAgcHJpdmF0ZSByb3V0ZXJTdGF0ZTtcbiAgICBwcml2YXRlIHN0b3JlU3RhdGU7XG4gICAgcHJpdmF0ZSB0cmlnZ2VyO1xuICAgIHByaXZhdGUgc3RhdGVLZXk7XG4gICAgY29uc3RydWN0b3Ioc3RvcmU6IFN0b3JlPGFueT4sIHJvdXRlcjogUm91dGVyLCBzZXJpYWxpemVyOiBSb3V0ZXJTdGF0ZVNlcmlhbGl6ZXI8U2VyaWFsaXplZFJvdXRlclN0YXRlU25hcHNob3Q+LCBlcnJvckhhbmRsZXI6IEVycm9ySGFuZGxlciwgY29uZmlnOiBTdG9yZVJvdXRlckNvbmZpZyk7XG4gICAgcHJpdmF0ZSBzZXRVcFN0b3JlU3RhdGVMaXN0ZW5lcjtcbiAgICBwcml2YXRlIG5hdmlnYXRlSWZOZWVkZWQ7XG4gICAgcHJpdmF0ZSBzZXRVcFJvdXRlckV2ZW50c0xpc3RlbmVyO1xuICAgIHByaXZhdGUgZGlzcGF0Y2hSb3V0ZXJSZXF1ZXN0O1xuICAgIHByaXZhdGUgZGlzcGF0Y2hSb3V0ZXJOYXZpZ2F0aW9uO1xuICAgIHByaXZhdGUgZGlzcGF0Y2hSb3V0ZXJDYW5jZWw7XG4gICAgcHJpdmF0ZSBkaXNwYXRjaFJvdXRlckVycm9yO1xuICAgIHByaXZhdGUgZGlzcGF0Y2hSb3V0ZXJOYXZpZ2F0ZWQ7XG4gICAgcHJpdmF0ZSBkaXNwYXRjaFJvdXRlckFjdGlvbjtcbiAgICBwcml2YXRlIHJlc2V0O1xufVxuIl19